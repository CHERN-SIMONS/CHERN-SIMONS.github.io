<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="[TOC] 引子 在C++发明阶段，C++之父Stroustrup和贝尔实验室的C++小组对原先的宏方法进行了修订，对其进行了简化并将它从预处理范围移入了编译器。这种新的代码替换装置被称为模板，而且它变现了完全不同的代码重用方法：**模板对源代码重用，而不是通过继承和组合重用对象代码。**当用户使用模板时，参数由编译器来替换，这非常像原来的宏方法，却更清晰，更容易使用。 模板使类和函数可在编译时定">
<meta property="og:type" content="article">
<meta property="og:title" content="Learning Notes">
<meta property="og:url" content="http://yoursite.com/2018/11/26/C++模板深度解析 (转载)/index.html">
<meta property="og:site_name" content="Learning Notes">
<meta property="og:description" content="[TOC] 引子 在C++发明阶段，C++之父Stroustrup和贝尔实验室的C++小组对原先的宏方法进行了修订，对其进行了简化并将它从预处理范围移入了编译器。这种新的代码替换装置被称为模板，而且它变现了完全不同的代码重用方法：**模板对源代码重用，而不是通过继承和组合重用对象代码。**当用户使用模板时，参数由编译器来替换，这非常像原来的宏方法，却更清晰，更容易使用。 模板使类和函数可在编译时定">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-11-26T11:05:09.285Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Learning Notes">
<meta name="twitter:description" content="[TOC] 引子 在C++发明阶段，C++之父Stroustrup和贝尔实验室的C++小组对原先的宏方法进行了修订，对其进行了简化并将它从预处理范围移入了编译器。这种新的代码替换装置被称为模板，而且它变现了完全不同的代码重用方法：**模板对源代码重用，而不是通过继承和组合重用对象代码。**当用户使用模板时，参数由编译器来替换，这非常像原来的宏方法，却更清晰，更容易使用。 模板使类和函数可在编译时定">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/11/26/C++模板深度解析 (转载)/">





  <title> | Learning Notes</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Learning Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/26/C++模板深度解析 (转载)/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-26T14:39:01+08:00">
                2018-11-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h1>引子</h1>
<p>在C++发明阶段，C++之父Stroustrup和贝尔实验室的C++小组对原先的宏方法进行了修订，对其进行了简化并将它从预处理范围移入了编译器。这种新的代码替换装置被称为模板，而且它变现了完全不同的代码重用方法：**模板对源代码重用，而不是通过继承和组合重用对象代码。**当用户使用模板时，参数由编译器来替换，这非常像原来的宏方法，却更清晰，更容易使用。</p>
<p>模板使类和函数可在编译时定义所需处理和返回的数据类型，一个模板并非一个实实在在的类或函数，仅仅<strong>是一个类和函数的描述</strong>。由于模板可以<strong>实现逻辑相同、数据类型不同的程序代码复制</strong>，所以使用模板机制可以减轻编程和维护的工作量和难度。<strong>模板一般分为模板函数和类模板</strong>。以所处理的数据类型的说明作为参数的类就叫<strong>类模板</strong>，或者<strong>模板类</strong>，而以所处理的数据类型的说明作为参数的函数，则称为<strong>函数模板</strong>。</p>
<p>本文包含函数模板和类模板，有些可能会交错设计两个模块的细节。</p>
<h1>函数模版</h1>
<p>函数模板定义了参数化的非成员函数，这使得程序员能够用不同类型的参数调用相同的函数，由编译器决定调用哪一种类型，并且从模板中生成相应的代码。</p>
<h2>定义</h2>
<p><strong>Template﹤类型参数表﹥返回类型 函数名 （形参表）{函数体}</strong></p>
<p>简单实例，调用函数打印字符串或数字等。</p>
<p>普通函数形式：</p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printstring</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"Hello World"</span>)</span></span>;    </span><br><span class="line">    printstring(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//输出：Hello World</span></span><br></pre></td></tr></table></figure></p>
<p>模板函数形式:</p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T&amp; var)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; var &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"Hello World"</span>)</span></span>;    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> num=<span class="number">1234</span>;</span><br><span class="line">    print(str);</span><br><span class="line">    print(num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：Hello World </span></span><br><span class="line"><span class="comment">//       1234</span></span><br></pre></td></tr></table></figure></p>
<p>可以看出使用模板后的函数不仅可以输出字符串形式还可以输出数字形式的内容。</p>
<p>上面两个例子介绍了函数模板的简单使用方法，但只有一个参数，如果需要多个参数，相应的函数模板应采用以下形式定义：</p>
<p><strong>Template﹤类型1 变量1，类型2 变量2 ，…﹥返回类型  函数名（形参表）{函数体}</strong></p>
<p>现在，为了看到模板时如何称为函数的，我们假定$min()$函数接受各种类型的参数，并找出其中的最小者，如果不采用模板技术，则只能接受一个特定类型的参数，如果希望也能接受其他类型的参数，就需要对每一种类型的参数都定义一个同功能的函数，其实为函数的重载，这里不在讨论，但这将是一件非常让人麻烦的事情。如：</p>
<p>普通定义：</p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义多态函数，找出三个整数中最小的数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min0</span><span class="params">(<span class="keyword">int</span> ii, <span class="keyword">int</span> jj, <span class="keyword">int</span> kk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">if</span>((ii&lt;jj)&amp;&amp;(ii&lt;kk))&#123;temp=ii;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((jj&lt;ii)&amp;&amp;(jj&lt;kk))&#123;temp=jj;    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;    temp=kk;    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义多态函数，找出三个小数中最小的数</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">min1</span><span class="params">(<span class="keyword">float</span> ii, <span class="keyword">float</span> jj, <span class="keyword">float</span> kk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> temp;</span><br><span class="line">    <span class="keyword">if</span>((ii&lt;jj)&amp;&amp;(ii&lt;kk))&#123;temp=ii;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((jj&lt;ii)&amp;&amp;(jj&lt;kk))&#123;temp=jj;    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;    temp=kk;    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义多态函数，找出三个子符中最小的字符</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">min2</span><span class="params">(<span class="keyword">char</span> ii, <span class="keyword">char</span> jj, <span class="keyword">char</span> kk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    <span class="keyword">if</span>((ii&lt;jj)&amp;&amp;(ii&lt;kk))    &#123;temp=ii;    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((jj&lt;ii)&amp;&amp;(jj&lt;kk))&#123;temp=jj;&#125;    </span><br><span class="line">    <span class="keyword">else</span>&#123;temp=kk;&#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp1=min0(<span class="number">100</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;temp1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">float</span> temp2=min1(<span class="number">10.60</span>,<span class="number">10.64</span>,<span class="number">53.21</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;temp2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">char</span> temp3=min2(<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'C'</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;temp3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以换行形式输出20  10.6  C</span></span><br></pre></td></tr></table></figure></p>
<p>使用模板：</p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义函数模板，找出三个值中最小的值，与数据类型无关</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">min</span>(<span class="title">T</span> <span class="title">ii</span>, <span class="title">T</span> <span class="title">jj</span>, <span class="title">T</span> <span class="title">kk</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T temp;</span><br><span class="line">    <span class="keyword">if</span>((ii&lt;jj)&amp;&amp;(ii&lt;kk))&#123;temp=ii;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((jj&lt;ii)&amp;&amp;(jj&lt;kk))&#123;temp=jj;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;    temp=kk; &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面是主函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;min(<span class="number">100</span>,<span class="number">20</span>,<span class="number">30</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;min(<span class="number">10.60</span>,<span class="number">10.64</span>,<span class="number">53.21</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;min(<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'C'</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果同上，但可以清楚的看到二者之间的工作量大小之差距。</p>
<p>函数模板功能非常强大，但是有时候可能会陷入困境，假如<strong>待比较的函数模板没有提供正确的操作符</strong>，则程序不会对此进行编译。为了避免这种错误，可以使用<strong>函数模板和同名的非模板函数重载，这就是函数定制</strong>。函数模板与同名的非模板函数重载必须遵守以下规定：</p>
<ol>
<li>
<p>寻找一个参数完全匹配的函数，如有，则调用它</p>
</li>
<li>
<p>如果失败，寻找一个函数模板，使其实例化，产生一个匹配的模板函数，若有，则调用它</p>
</li>
<li>
<p>如果失败，再试低一级的对函数重载的方法，例如通过类型转换可产生的参数匹配等，</p>
<p>若找到匹配的函数，调用它</p>
</li>
<li>
<p>如果失败，则证明这是一个错误的调用</p>
</li>
</ol>
<p>现在用上例的模板函数比较两个字符串，但会出现问题:</p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义函数模板，找出三个值中最小的值，与数据类型无关</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">min</span>(<span class="title">T</span> <span class="title">ii</span>, <span class="title">T</span> <span class="title">jj</span>, <span class="title">T</span> <span class="title">kk</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T temp;</span><br><span class="line">    <span class="keyword">if</span>((ii&lt;jj)&amp;&amp;(ii&lt;kk))&#123;     temp=ii; &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((jj&lt;ii)&amp;&amp;(jj&lt;kk))&#123; temp=jj; &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;    temp=kk;&#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;min(<span class="string">"anderson"</span>,<span class="string">"Washington"</span>,<span class="string">"Smith"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出anderson与实际结果不符，原因在于编译器会生成对字符串指针做比较的函数，但比较字符串和比较字符串指针是不一样的，为了解决此问题，我们可以定制函数模板，如：</p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// 定义函数模板，找出三个值中最小的值，与数据类型无关</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">min</span>(<span class="title">T</span> <span class="title">ii</span>, <span class="title">T</span> <span class="title">jj</span>, <span class="title">T</span> <span class="title">kk</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T temp;</span><br><span class="line">    <span class="keyword">if</span>((ii&lt;jj)&amp;&amp;(ii&lt;kk))&#123;        temp=ii;    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((jj&lt;ii)&amp;&amp;(jj&lt;kk))&#123;        temp=jj;    &#125;</span><br><span class="line">    <span class="keyword">else</span>    &#123;        temp=kk;    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非模板函数重载</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">min</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ch1, <span class="keyword">const</span> <span class="keyword">char</span>* ch2,<span class="keyword">const</span> <span class="keyword">char</span>* ch3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* temp;</span><br><span class="line">    <span class="keyword">int</span> result1 = <span class="built_in">strcmp</span>(ch1,ch2);</span><br><span class="line">    <span class="keyword">int</span> result2 = <span class="built_in">strcmp</span>(ch1,ch3);</span><br><span class="line">    <span class="keyword">int</span> result3 = <span class="built_in">strcmp</span>(ch2,ch1);</span><br><span class="line">    <span class="keyword">int</span> result4 = <span class="built_in">strcmp</span>(ch2,ch3);</span><br><span class="line">    <span class="keyword">if</span>((result1&lt;<span class="number">0</span>)&amp;&amp;(result2&lt;<span class="number">0</span>))    &#123;        temp = ch1;    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((result3&lt;<span class="number">0</span>)&amp;&amp;(result4&lt;<span class="number">0</span>))    &#123;        temp=ch2;    &#125;</span><br><span class="line">    <span class="keyword">else</span>    &#123;        temp=ch3;    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;min(<span class="number">100</span>,<span class="number">20</span>,<span class="number">30</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;min(<span class="number">10.60</span>,<span class="number">10.64</span>,<span class="number">53.21</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;min(<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'C'</span>)&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;min(<span class="string">"anderson"</span>,<span class="string">"Washington"</span>,<span class="string">"Smith"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在VS2010中，最后一行会输出Smith，与结果相符。 下面给出一个实例:</p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HEADER_MY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEADER_MY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">fromString</span>(<span class="title">const</span> <span class="title">std</span>:</span>:<span class="built_in">string</span> &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(s)</span></span>;</span><br><span class="line">    T t;</span><br><span class="line">    is&gt;&gt;t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:<span class="function"><span class="built_in">string</span> <span class="title">toString</span><span class="params">(<span class="keyword">const</span> T &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">ostringstream</span> t;</span><br><span class="line">    t&lt;&lt;s;</span><br><span class="line">    <span class="keyword">return</span> t.str();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"header_my.h"</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;complex&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1234</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"i == \""</span> &lt;&lt; toString(i) &lt;&lt; <span class="string">"\"\n"</span>; </span><br><span class="line">    <span class="keyword">float</span> x = <span class="number">567.89</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"x == \""</span> &lt;&lt; toString(x) &lt;&lt; <span class="string">"\"\n"</span>; </span><br><span class="line">    <span class="keyword">complex</span>&lt;<span class="keyword">float</span>&gt; c(<span class="number">1.0</span>, <span class="number">2.0</span>); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c == \""</span> &lt;&lt; toString(c) &lt;&lt; <span class="string">"\"\n"</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    i = fromString&lt;<span class="keyword">int</span>&gt;(<span class="built_in">string</span>(<span class="string">"1234"</span>)); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"i == "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    x = fromString&lt;<span class="keyword">float</span>&gt;(<span class="built_in">string</span>(<span class="string">"567.89"</span>)); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"x == "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    c = fromString&lt; <span class="keyword">complex</span>&lt;<span class="keyword">float</span>&gt; &gt;(<span class="built_in">string</span>(<span class="string">"(1.0,2.0)"</span>)); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c == "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2>模板实参推演</h2>
<p>当函数模板被调用时，<strong>对函数实参类型的检查决定了模板实参的类型和值的这个过程叫做模板实参推演</strong>。如**template <code>&lt;class T&gt;</code> void h(T a){}; h(1); h(0.2); ** 第一个调用因为实参是int型的，所以模板形参T被推演为int型，第二个T的类型则为double。</p>
<p>在使用函数模板时，请注意以下几点：</p>
<ol>
<li>
<p>在模板被实例化后，就会生成一个新的实例，这个<strong>新生成的实例不存在类型转换</strong>。比如有函数模板</p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">H</span>(<span class="title">T</span> <span class="title">a</span>)&#123;</span>&#125;; </span><br><span class="line"><span class="keyword">int</span> a=<span class="number">2</span>; </span><br><span class="line"><span class="keyword">short</span> b=<span class="number">3</span>;</span><br><span class="line">H(a);</span><br><span class="line">H(b);</span><br></pre></td></tr></table></figure></p>
<p>第一个调用H(a)生成一个int型的实例版本，但是当调用H(b)的时候不会使用上次生成的int实例把short转换为int，而是会另外生成一个新的short型的实例。</p>
</li>
<li>
<p>在模板实参推演的过程中有时类型并不会完全匹配，这时编译器允许以下几种实参到模板形参的转换，这些转换不会生成新的实例。</p>
<p>2.1 数组到指针的转换或函数到指针的转换：比如template<code>&lt;class T&gt;</code> void h(T <em>a){}，int b[3]={1,2,3}；h(b);这时数组b和类型T</em> 不是完全匹配，但允许从数组到指针的转换，因此数组b被转换成int <em>，而类型形参T被转换成int，也就是说函数体中的T被替换成int。</em></p>
<p>2.2 <em>限制修饰符转换：即把const或volatile限定符加到指针上。比如template&lt;class T&gt; void h(const T</em> a){}，int b=3; h(&amp;b);虽然实参&amp;b与形参const T<em>不完全匹配，但因为允许限制修饰符的转换，结果就把&amp;b转换成const int</em> 。而类形型参T被转换成int。如果模板形参是非const类型，则无论实参是const类型还是非const类型调用都不会产生新的实例。</p>
<p>2.3 到一个基类的转换(该基类根据一个类模板实例化而来)：比如tessmplate<code>&lt;class T1&gt;</code> class A{}; template<code>&lt;class T1&gt;</code> class B:public A<code>&lt;T1&gt;</code>{}; template<code>&lt;class T2&gt;</code> void h(A<code>&lt;T2&gt;</code>&amp; m){}，在main函数中有B<code>&lt;int&gt;</code> n; h(n);函数调用的子类对象n与函数的形参A<code>&lt;T2&gt;</code>不完全匹配，但允许到一个基类的转换。在这里转换的顺序为，首先把子类对象n转换为基类对象A<code>&lt;int&gt;</code>，然后再用A<code>&lt;int&gt;</code>去匹配函数的形参A<code>&lt;T2&gt;</code>&amp;，所以最后T2被转换为int，也就是说函数体中的T将被替换为int。</p>
<p>2.4  对于函数模板而言不存在h(int,int)这样的调用，不能在函数调用的参数中指定模板形参的类型，对函数模板的调用应使用实参推演来进行，即只能进行h(2,3)这样的调用，或者int a, b; h(a,b)。</p>
</li>
</ol>
<p>模板实参推演实例，说明内容较长，采用注释形式，但代码较乱：</p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">void</span> <span class="title">h</span>(<span class="title">T</span> <span class="title">a</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">" h()"</span> &lt;&lt; <span class="keyword">typeid</span>(T).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;  <span class="comment">//带有一个类型形参T的模板函数的定义方法，typeid(变量名).name()为测试变量类型的语句。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">k</span>(<span class="title">T</span> <span class="title">a</span>,<span class="title">T</span> <span class="title">b</span>)&#123;</span></span><br><span class="line">    T c;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">" k()"</span>&lt;&lt;<span class="keyword">typeid</span>(T).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="comment">//注意语句T c。模板类型形参T可以用来声明变量，作为函数的返回类型，函数形参等凡是类类型能使用的地方。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt; <span class="title">void</span> <span class="title">f</span>(<span class="title">T1</span> <span class="title">a</span>, <span class="title">T2</span> <span class="title">b</span>)&#123;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">" f()"</span>&lt;&lt;<span class="keyword">typeid</span>(T1).name()&lt;&lt;<span class="string">","</span>&lt;&lt;<span class="keyword">typeid</span>(T2).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;   <span class="comment">//定义带有两个类型形参T1，T2的模板函数的方法template&lt;class T&gt; void g(const T* a)&#123;T b;cout&lt;&lt;" g()"&lt;&lt;typeid(b).name()&lt;&lt;endl;&#125; </span></span><br><span class="line"><span class="comment">//template&lt;class T1,class T2=int&gt; void g()&#123;&#125;  //错误，默认模板类型形参不能用于函数模板，只能用于类模板上。</span></span><br><span class="line"><span class="comment">//main函数开始</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// template&lt;class T&gt;void h()&#123;&#125; //错误，模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行。</span></span><br><span class="line"><span class="comment">//函数模板实参推演示例。</span></span><br><span class="line"><span class="comment">// h(int); //错误，对于函数模板而言不存在h(int,int)这样的调用，不能在函数调用的参数中指定模板形参的类型，对函数模板的调用应使用实参推演来进行，即只能进行h(2,3)这样的调用，或者int a, b; h(a,b)。</span></span><br><span class="line"><span class="comment">//h函数形式为：template&lt;class T&gt;void h(T a)</span></span><br><span class="line">h(<span class="number">2</span>);<span class="comment">//输出" h() int"使用函数模板推演，在这里数值2为int型，所以把类型形参T推演为int型。</span></span><br><span class="line">h(<span class="number">2.0</span>);<span class="comment">//输出" h() double"，因为2.0为double型，所以将函数模板的类型形参推演为double型</span></span><br><span class="line"><span class="comment">//k函数形式为：template&lt;class T&gt;void k(T a,T b)</span></span><br><span class="line">k(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//输出" k() int"</span></span><br><span class="line"><span class="comment">//k(2,3.0);错误，模板形参T的类型不明确，因为k()函数第一个参数类型为int，第二个为double型，两个形参类型不一致。</span></span><br><span class="line"><span class="comment">//f函数的形式为：template&lt;class T1,class T2&gt; void f(T1 a, T2 b)</span></span><br><span class="line">f(<span class="number">3</span>,<span class="number">4.0</span>);<span class="comment">//输出" f() int,double"，这里不存在模板形参推演错误的问题，因为模板函数有两个类型形参T1和T2。在这里将T1推演为int，将T2推演为double。</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">3</span>;<span class="keyword">double</span> b=<span class="number">4</span>;</span><br><span class="line">f(a,b); <span class="comment">//输出同上，这里用变量名实现推板实参的推演。</span></span><br><span class="line"><span class="comment">//模板函数推演允许的转换示例，g函数的形式为template&lt;class T&gt; void g(const T* a)</span></span><br><span class="line"><span class="keyword">int</span> a1[<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;g(a1); <span class="comment">//输出" g() int"，数组的地址和形参const T*不完全匹配，所以将a1的地址T &amp;转换为const T*，而a1是int型的，所以最后T推演为int。</span></span><br><span class="line">g(&amp;b); <span class="comment">//输出" g() double",这里和上面的一样，只是把类型T转换为double型。</span></span><br><span class="line">h(&amp;b); <span class="comment">//输出" h() double *"这里把模参类型T推演为double *类型。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2>函数模板的显式实例化</h2>
<ol>
<li>隐式实例化：比如有模板函数template<code>&lt;class T&gt;</code> void h(T a){}。h(2)这时h函数的调用就是隐式实例化，即参数T的类型是隐式确定的。</li>
<li>函数模板显式实例化声明：其语法是：<strong>template 函数返回类型 函数名 <code>&lt;实例化的类型&gt;</code> (函数形参表)</strong>; 注意这是声明语句，要以分号结束。例如：template void h<code>&lt;int&gt;</code> (int a);这样就创建了一个h函数的int 实例。再如有模板函数template<code>&lt;class T&gt;</code> T h(T a){}，注意这里h函数的返回类型为T，显式实例化的方法为template int h<code>&lt;int&gt;</code>(int a); 把h模板函数实例化为int型。</li>
<li>对于给定的函数模板实例，显式实例化声明在一个文件中只能出现一次。</li>
<li>在显式实例化声明所在的文件中，函数模板的定义必须给出，如果定义不可见，就会发生错误。</li>
</ol>
<p>注意：不能在局部范围类显式实例化模板，实例化模板应放在全局范围内，即不能在main函数等局部范围中实例化模板。因为模板的声明或定义不能在局部范围或函数内进行。</p>
<h2>显式模板实参</h2>
<ol>
<li>显式模板实参：适用于函数模板，即在调用函数时显式指定要调用的实参的类型。</li>
<li>格式：显式模板实参的格式为在调用模板函数的时候在函数名后用<code>&lt;&gt;</code>尖括号括住要显示表示的类型，比如有模板函数template<code>&lt;class T&gt;</code> void h(T a, T b){}。则h<code>&lt;double&gt;</code>(2, 3.2)就把模板形参T显式实例化为double类型。</li>
<li>显式模板实参用于同一个模板形参的类型不一致的情况。比如template<code>&lt;class T&gt;</code> void h(T a, T b){}，则h(2, 3.2)的调用会出错，因为两个实参类型不一致，第一个为int 型，第二个为double型。而用h<code>&lt;double&gt;</code>(2, 3.2)就是正确的，虽然两个模板形参的类型不一致但这里把模板形参显式实例化为double类型，这样的话就允许进行标准的隐式类型转换，即这里把第一个int 参数转换为double类型的参数。</li>
<li>显式模板实参用法二：用于函数模板的返回类型中。例如有模板函数template<code>&lt;class T1, class T2, class T3&gt;</code> T1 h(T2 a, T3 b){}，则语句int a=h(2,3)或h(2,4)就会出现模板形参T1无法推导的情况。而语句int h(2,3)也会出错。用显式模板实参就能轻松解决这个问题，比如h<code>&lt;int, int, int&gt;</code>(2,3)即把模板形参T1实例化为int 型，T2和T3也实例化为int 型。</li>
<li>显式模板实参用法三：应用于模板函数的参数中没有出现模板形参的情况。比如template<code>&lt;class T&gt;</code>void h(){}如果在main函数中直接调用h函数如h()就会出现无法推演类型形参T的类型的错误，这时用显式模板实参就不会出现这种错误，调用方法为h<code>&lt;int&gt;</code>()，把h函数的模板形参实例化为int 型，从而避免这种错误。</li>
<li>显式模板实参用法四：用于函数模板的非类型形参。比如template<code>&lt;class T,int a&gt;</code> void h(T b){}，而调用h(3)将出错，因为这个调用无法为非类型形参推演出正确的参数。这时正确调用这个函数模板的方法为h<code>&lt;int, 3&gt;</code>(4)，首先把函数模板的类型形参T推演为int 型，然后把函数模板的非类型形参int a用数值3来推演，把变量a设置为3，然后再把4传递给函数的形参b，把b设置为4。注意，因为int a是非类型形参，所以调用非类型形参的实参应是编译时常量表达式，不然就会出错。</li>
<li>在使用显式模板实参时，我们只能省略掉尾部的实参。比如template<code>&lt;class T1, class T2, class T3&gt;</code> T1 h(T2 a, T3 b){}在显式实例化时h<code>&lt;int&gt;</code>(3, 3.4)省略了最后两个模板实参T2和T3，T2和T3由调用时的实参3和3.4隐式确定为int 型和double型，而T1被显示确定为int 型。h<code>&lt;int, , double&gt;``&lt;2,3.4&gt;</code>是错误的，只能省略尾部的实参。</li>
<li>显式模板实参最好用在存在二义性或模板实参推演不能进行的情况下。</li>
</ol>
<p>下面来看看实例：</p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">void</span> <span class="title">g1</span>(<span class="title">T</span> <span class="title">a</span>, <span class="title">T</span> <span class="title">b</span>)&#123;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"hansu g1()"</span>&lt;&lt;<span class="keyword">typeid</span>(T).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>,<span class="title">class</span> <span class="title">T3</span>&gt;<span class="title">T1</span> <span class="title">g2</span>(<span class="title">T2</span> <span class="title">a</span>,<span class="title">T3</span> <span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T1 c=a;<span class="built_in">cout</span>&lt;&lt;<span class="string">"hansug2()"</span>&lt;&lt;<span class="keyword">typeid</span>(T1).name()</span><br><span class="line">        &lt;&lt;<span class="keyword">typeid</span>(T2).name()&lt;&lt;<span class="keyword">typeid</span>(T3).name()&lt;&lt;<span class="built_in">endl</span>; <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt; <span class="title">void</span> <span class="title">g3</span> ( <span class="title">T1</span> <span class="title">a</span> ) &#123;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"hansu g3()"</span>&lt;&lt;<span class="keyword">typeid</span>(T1).name()&lt;&lt;<span class="keyword">typeid</span>(T2).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">int</span> <span class="title">a</span>&gt; <span class="title">void</span> <span class="title">g4</span>(<span class="title">T1</span> <span class="title">b</span>, <span class="title">double</span> <span class="title">c</span>)&#123;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"hansu g4()"</span>&lt;&lt;<span class="keyword">typeid</span>(T1).name()&lt;&lt;<span class="keyword">typeid</span>(a).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt; <span class="title">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//模板显示实例化示例。</span></span><br><span class="line"><span class="comment">//因为模板的声明或定义不能在局部范围或函数内进行。所以模板实例化都应在全局范围内进行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">void</span> g1&lt;<span class="keyword">double</span>&gt;(<span class="keyword">double</span> a,<span class="keyword">double</span> b); <span class="comment">//把函数模板显示实例化为int型。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;double,double&gt;;</span> <span class="comment">//显示实例化类模板，注意后面没有对象名，也没有&#123;&#125;大括号。</span></span><br><span class="line"><span class="comment">//template class A&lt;int,int&gt;&#123;&#125;;  //错误，显示实例化类模板后面不能有大括号&#123;&#125;。</span></span><br><span class="line"><span class="comment">//template class A&lt;int,int&gt; m;  //错误，显示实例化类模板后面不能有对象名。</span></span><br><span class="line"><span class="comment">//main函数开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//显示模板实参示例。显示模板实参适合于函数模板</span></span><br><span class="line"><span class="comment">//1、显示模板实参用于同一个模板形参的类型不一致的情况。函数g1形式为template&lt;class T&gt;void g1(T a, T b)</span></span><br><span class="line">g1&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>,<span class="number">3.2</span>);<span class="comment">//输出"hansu g1() int"两个实参类型不一致，第一个为int第二个为double。但这里用显示模板实参把类型形参T指定为double，所以第一个int型的实参数值2被转换为double类型。</span></span><br><span class="line"><span class="comment">//g1(2,3.2);错误，这里没有用显式模板实参。所以两个实参类型不一致。</span></span><br><span class="line"><span class="comment">//2、用于函数模板的反回类型中。函数g2形式为template&lt;class T1,class T2,class T3&gt; T1 g2(T2 a,T3 b)</span></span><br><span class="line"><span class="comment">//g2(2,3);错误，无法推演类型形参T1。</span></span><br><span class="line"><span class="comment">//int g2(2,3);错误，不能以这种方法试图推导类型形参T1为int型。</span></span><br><span class="line"><span class="comment">//int a=g2(2,3);错误，以这种方式试图推演出T1的类型为int也是错误的。</span></span><br><span class="line">g2&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//正确，将T1，T2，T3 显示指定为int型。输出"hansu g2() intintint"</span></span><br><span class="line"><span class="comment">//3、应用于模板函数的参数中没有出现模板形参的情况其中包括省略的用法，函数g3的形式为template&lt;class T1,class T2&gt; void g3(T1 a)</span></span><br><span class="line"><span class="comment">//g3(2);错误，无法为函数模板的类型形参T2推演出正确的类型</span></span><br><span class="line"><span class="comment">//g3(2,3);错误，岂图以这种方式为T2指定int型是错误的，因为函数只有一个参数。</span></span><br><span class="line"><span class="comment">//g3&lt;,int&gt;(2);错误，这里起图用数值2来推演出T1为int型,而省略掉第一个的显示模板实参，这种方法是错误的。在用显示模板实参时，只能省略掉尾部的实参。</span></span><br><span class="line"><span class="comment">//g3&lt;int&gt;(2);错误，虽然用了显示模板实参方法，省略掉了尾部的实参，但该方法只是把T1指定为int型，仍然无法为T2推演正确的类型。</span></span><br><span class="line">g3&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(<span class="number">2</span>);<span class="comment">//正确，显示指定T1和T2的类型都为int型。</span></span><br><span class="line"><span class="comment">//4、用于函数模板的非类型形参。g4函数的形式为template&lt;class T1,int a&gt; void g4(T1 b,double c)</span></span><br><span class="line"><span class="comment">//g4(3,3.2);错误，虽然指定了两个参数，但是这里仍然无法为函数模板的非类型形参int a推演出正确的实参。因为第二个函数参数x.2是传递给函数的参数double c的，而不是函数模板的非类型形参int a。</span></span><br><span class="line"><span class="comment">//g4(3,2);错误，起图以整型值把实参传递给函数模板的非类型形参是不行的，这里数值2会传递给函数形参double c并把int型转换为double型。所以非类型形参int a仍然无实参。</span></span><br><span class="line"><span class="comment">//int d=1; g4&lt;int ,d &gt;(3,3.2); //错误，调用方法正确，但对于非类型形参要求实参是一个常量表达式，而局部变量c是非常量表达式，不能做为非类型形参的实参，所以错误。</span></span><br><span class="line">g4&lt;<span class="keyword">int</span>,<span class="number">1</span>&gt;(<span class="number">2</span>,<span class="number">3.2</span>);<span class="comment">//正确，用显示模板实参，把函数模板的类型形参T1设为int型，把数值1传给非类型形参int a，并把a设为1，把数值2 传给函数的第一个形参T1 b并把b设为2，数值?.2传给函数的第二个形参double c并把c设为?.2。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> d=<span class="number">1</span>; g4&lt;<span class="keyword">int</span>,d&gt;(<span class="number">2</span>,<span class="number">3.2</span>);<span class="comment">//正确，这里变量d是const常量，能作为非类型形参的实参，这里参数的传递方法同上面的语句。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2>显式具体化(模板特化，模板说明) 和函数模板的重载</h2>
<p>具体化或特化或模板说明指的是一个意思，就是把模板特殊化，比如有模板template<code>&lt;class T&gt;</code>void h(T a){}，这个模板适用于所有类型，但是有些特殊类型不需要与这个模板相同的操作或者定义，比如int 型的h实现的功能和这个模板的功能不一样，这样的话我们就要重定义一个h模板函数的int版本，即特化版本。</p>
<h3>特化函数模板：</h3>
<p>显式特化格式为：<strong>template<code>&lt;&gt;</code> 返回类型函数名<code>&lt;要特化的类型&gt;</code>(参数列表) {函数体}</strong>，显式特化以template<code>&lt;&gt;</code>开头，表明要显式特化一个模板，在函数名后<code>&lt;&gt;</code>用尖括号括住要特化的类型版本。比如template <code>&lt;class T&gt;</code> void h(T a){}，其int 类型的特化版本为template<code>&lt;&gt;</code> void h<code>&lt;int&gt;</code>(int a){}，当出现int 类型的调用时就会调用这个特化版本，而不会调用通用的模板，比如h(2)，就会调用int 类型的特化版本。</p>
<p>如果可以从实参中推演出模板的形参，则可以省略掉显示模板实参的部分。比如：template<code>&lt;&gt;</code> void h(int a){}。注意函数h后面没有<code>&lt;&gt;</code>符号，即显式模板实参部分。</p>
<p>对于返回类型为模板形参时，调用该函数的特化版本必须要用显式模板实参调用，如果不这样的话就会出现其中一个形参无法推演的情况。如template<code>&lt;class T1,class T2,class T3&gt;</code> T1 h(T2 a,T3 b){}，有几种特化情况：
情况一：template<code>&lt;&gt;</code> int h<code>&lt;int,int&gt;</code>(int a, in b){}该情况下把T1，T2，T3的类型推演为int 型。在主函数中的调用方式应为h<code>&lt;int&gt;</code>(2,3)。</p>
<p>情况二：template<code>&lt;&gt;</code> int h(int a, int b){}，这里把T2,T3推演为int 型，而T1为int 型，但在调用时必须用显式模板实参调用，且在<code>&lt;&gt;</code>尖括号内必须指定为int 型，不然就会调用到通用函数模板，如h<code>&lt;int&gt;</code>(2,3)就会调用函数模板的特化版本，而h(2,3)调用会出错。h<code>&lt;double&gt;</code>(2,3)调用则会调用到通用的函数模板版本。</p>
<p>这几种情况的特化版本是错误的，如template<code>&lt;&gt;</code> T1 h(int a,int b){}，这种情况下T1会成为不能识别的名字，因而出现错误，template<code>&lt;&gt;</code> int h<code>&lt;double&gt;</code>(int a,int b){}在这种情况下返回类型为int 型，把T1确定为int 而尖括号内又把T1确定为double型，这样就出现了冲突。</p>
<p>具有相同名字和相同数量返回类型的非模板函数(即普通函数)，也是函数模板特化的一种情况，这种情况将在后面参数匹配问题时讲解。</p>
<h3>特化类模板：</h3>
<p>特化整个类模板：比如有template<code>&lt;class T1,class T2&gt;</code> class A{}; 其特化形式为<strong>template<code>&lt;&gt;</code> class A<code>&lt;int, int&gt;</code>{};</strong> 特化形式以template<code>&lt;&gt;</code>开始，这和模板函数的形式相同，在类名A后跟上要特化的类型。</p>
<p>在类特化的外部定义成员的方法：比如template<code>&lt;class T&gt;</code> class A{public: void h();};类A特化为template<code>&lt;&gt;</code> class A<code>&lt;int&gt;</code>{public: void h();};在类外定义特化的类的成员函数h的方法为：void A<code>&lt;int&gt;</code>::h(){}。在外部定义类特化的成员时应省略掉template<code>&lt;&gt;</code>。</p>
<p>类的特化版本应与类模板版本有相同的成员定义，如果不相同的话那么当类特化的对象访问到类模板的成员时就会出错。因为当调用类的特化版本创建实例时创建的是特化版本的实例，不会创建类模板的实例，特化版本如果和类的模板版本的成员不一样就有可能出现这种错误。比如：模板类A中有成员函数h()和f()，而特化的类A中没有定义成员函数f()，这时如果有一个特化的类的对象访问到模板类中的函数f()时就会出错，因为在特化类的实例中找不到这个成员。</p>
<p>类模板的部分特化：比如有类模板template<code>&lt;class T1, class T2&gt;</code> class A{};则部分特化的格式为template<code>&lt;class T1&gt;</code> class A<code>&lt;T1, int&gt;</code>{};将模板形参T2特化为int 型，T1保持不变。部分特化以template开始，在<code>&lt;&gt;</code>中的模板形参是不用特化的模板形参，在类名A后面跟上要特化的类型。如果要特化第一个模板形参T1，则格式为template<code>&lt;class T2&gt;</code> class A<code>&lt;int, T2&gt;</code>{};部分特化的另一用法是template<code>&lt;class T1&gt;</code> class A<code>&lt;T1,T1&gt;</code>{};将模板形参T2也特化为模板形参T1的类型。</p>
<p>在类部分特化的外面定义类成员的方法：比如有部分特化类template<code>&lt;class T1&gt;</code> class A<code>&lt;T1,int&gt;</code>{public: void h();};则在类外定义的形式为template<code>&lt;class T1&gt;</code> void A<code>&lt;T1,int&gt;</code>::h(){}。注意当在类外面定义类的成员时template 后面的模板形参应与要定义的类的模板形参一样，这里就与部分特化的类A的一样template<code>&lt;class T1&gt;</code>。</p>
<p>可以对模板的特化版本只进行声明，而不定义。比如template<code>&lt;&gt;</code> void h<code>&lt;int&gt;</code>(int a);注意，声明时后面有个分号。</p>
<p>在调用模板实例之前必须要先对特化的模板进行声明或定义。一个程序不允许同一模板实参集的同一模板既有显式特化又有实例化。比如有模板template<code>&lt;class T&gt;</code> void h(T a){}在h(2)之前没有声明该模板的int 型特化版本，而是在调用该模板后定义该模板的int 型特化版本，这时程序不会调用该模板的特化版本，而是调用该模板产生一个新的实例。这里就有一个问题，到底是调用由h(2)产生的实例版本呢还是调用程序中的特化版本。</p>
<p>注意：因为模板的声明或定义不能在局部范围或函数内进行。所以特化类模板或函数模板都应在全局范围内进行。</p>
<p>在特化版本中模板的类型形参是不可见的。比如template<code>&lt;&gt;</code> void h<code>&lt;int,int&gt;</code>(int a,int b){T1 a;}就会出现错误，在这里模板的类型形参T1在函数模板的特化版本中是不可见的，所以在这里T1是未知的标识符，是错误的。</p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//函数模板特化和类模板特化示例</span></span><br><span class="line"><span class="comment">//定义函数g1，g2和类A</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt; <span class="title">void</span> <span class="title">g1</span>(<span class="title">T1</span> <span class="title">a</span>,<span class="title">T2</span> <span class="title">b</span>)&#123;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"g1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>,<span class="title">class</span> <span class="title">T3</span>&gt;<span class="title">T1</span> <span class="title">g2</span>(<span class="title">T2</span> <span class="title">a</span>,<span class="title">T3</span> <span class="title">b</span>)&#123;</span></span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">1</span>;<span class="built_in">cout</span>&lt;&lt;<span class="string">"g2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>,<span class="title">class</span> <span class="title">T3</span>&gt;<span class="title">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数模板的特化定义。函数模板的特化可以理解为函数模板重载的另一种形式。</span></span><br><span class="line"><span class="comment">//下式为g1的类型形参显示指定其类型，把T1，T2在模板实参的尖括号中设为int型。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">void</span> g1&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"g1一"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下式显示设定g1的类型形参T1，并设为int型，T2由函数参数double推演为double型。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">void</span> g1&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span> a,<span class="keyword">double</span> b)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"g1二"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">g1</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"g1三"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="comment">//g1的类型形参都由g1的形参推演出来。</span></span><br><span class="line"><span class="comment">//template&lt;&gt; void g1&lt;int&gt;(double a,int b)&#123;cout&lt;&lt;"g•一"&lt;&lt;endl;&#125;  //错误，在显示模板实参的尖括号中显示把类型形参T1的类型设为int型，而又在函数的形参中把类型形参T1的类型推演为double型，这样就发生了冲突，出现错误。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">int</span> g2&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">1</span>;<span class="built_in">cout</span>&lt;&lt;<span class="string">"g2一"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="function"><span class="keyword">double</span> <span class="title">g2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">1</span>;<span class="built_in">cout</span>&lt;&lt;<span class="string">"g2二"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意，下式正确，该式并不是对函数模板g2的部分特化，而是g2的重载。</span></span><br><span class="line"><span class="comment">//template&lt;class T2&gt; int g2(int a, T2 b)&#123;int c=1;cout&lt;&lt;"g2三"&lt;&lt;endl;return c;&#125;</span></span><br><span class="line"><span class="comment">//下式错误，函数反回类型和&lt;double&gt;尖括号中的double类型不同，发生冲突。</span></span><br><span class="line"><span class="comment">//template&lt;&gt; int g2&lt;double&gt;(int a,int b)&#123;int c=1;cout&lt;&lt;"two"&lt;&lt;endl;return c;&#125; </span></span><br><span class="line"><span class="comment">//下式错误，函数模板的类型形参在特化版本中是不可见的，也就是说这里的会把类型形参T1理解为未声明的标识符</span></span><br><span class="line"><span class="comment">//template&lt;&gt; T1 g2&lt;int&gt;(int a,int b)&#123;int c=1;cout&lt;&lt;"two"&lt;&lt;endl;return c;&#125; </span></span><br><span class="line"><span class="comment">//类模板的特化和部分特化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;int,int,int&gt;&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;<span class="comment">//特化整个类模板的格式，注意类名后的尖括号中必须指定所有的类模板的类型形参。</span></span><br><span class="line"><span class="comment">//template&lt;&gt; class A&lt;int&gt;&#123;&#125;; //错误，在特化的类名后的尖括号中指定的类模板类型形参的数量不够。要想只特化其中一个类模板的类型形参，就要使用类模板的部分特化。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T3</span>&gt;<span class="title">class</span> <span class="title">A</span>&lt;T1,double,T3&gt;&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;<span class="comment">//特化T2，而T1和T?不特化，注意尖括号中的类型形参是不特化的形参。</span></span><br><span class="line"><span class="comment">//在类模板的特化或部分特化版本的外部定义成员函数的方法。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> A&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::h()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"class A tehua"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="comment">/*  T1 c; 错误，在特化版本中模板的类型形参是不可见的，也就是说在这里</span></span><br><span class="line"><span class="comment">T1是未声明的标识符。*/</span></span><br><span class="line"><span class="comment">//template&lt;&gt; void A&lt;int,int,int&gt;::h()&#123;&#125; //错误，在类模板的特化版本外面定义类模板的成员时应省略掉template&lt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T3</span>&gt;<span class="title">void</span> <span class="title">A</span>&lt;T1,double,T3)::h()&#123;</span></span><br><span class="line"><span class="class">    cout&lt;&lt;"class A bute"&lt;&lt;endl;</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">template&lt;class T1,class T2,class T3&gt;void A&lt;T1,T2,T3&gt;::h()&#123;</span></span><br><span class="line"><span class="class">    cout&lt;&lt;"class A putong"&lt;&lt;endl;</span></span><br><span class="line"><span class="class">&#125; //定义普通类模板中的成员函数。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//main函数开始</span></span><br><span class="line"><span class="class">int main()</span></span><br><span class="line"><span class="class">&#123;   //特化的函数模板的调用方式。</span></span><br><span class="line"><span class="class">    g1(2,2); //输出"g1一"，调用函数模板g1的第一个特化版本template&lt;&gt; void g1&lt;int,int&gt;(int a,int b)&#123;cout&lt;&lt;"g1一"&lt;&lt;endl;&#125;</span></span><br><span class="line"><span class="class">    g1(2,3.2); //输出"g1二"，调用函数模板g1的第二个特化版本template&lt;&gt; void g1&lt;int&gt;(int a,double b)&#123;cout&lt;&lt;"g1二"&lt;&lt;endl;&#125;</span></span><br><span class="line"><span class="class">    g1(3.3,4.4); //输出"g1三"，调用函数模板g1的第三个特化版本template&lt;&gt; void g1(double a,double b)&#123;cout&lt;&lt;"g1三"&lt;&lt;endl;&#125;</span></span><br><span class="line"><span class="class">    g1&lt;double&gt;(3,2.3);//输出"g1三"，这里用显示模板实参把第一个实参指定为double型，这样g1的两个实参都是double型，所以将调用g1的第三个特化版本。</span></span><br><span class="line"><span class="class">    //g2(3,3); 错误，在调用反回类型为类型形参的时候必须用显示模板实参的形式为反回类型的形参显示指定类型。在这里就会出现无法为T1确定类型的情况。</span></span><br><span class="line"><span class="class">    g2&lt;int&gt;(2,3);//正确，把g2的类型形参T1设显示指定为int，调用g2的第一个特化版本。template&lt;&gt; int g2&lt;int&gt;(int a,int b)&#123;int c=1;cout&lt;&lt;"g2一"&lt;&lt;endl;return c;&#125;</span></span><br><span class="line"><span class="class">    g2&lt;double&gt;(2,3);//正确，把g2的类型形参T1设显示指定为double，调用g2的第二个特化版本。template&lt;&gt; double g2(int a,int b)&#123;int c=1;cout&lt;&lt;"g2二"&lt;&lt;endl;return c;&#125;</span></span><br><span class="line"><span class="class">    g2&lt;char&gt;(2,3);//正确，把g2的类型形参T1设显示指定为char，对于char版本的g2函数没有特化版本，因此调用g2的通用版本。</span></span><br><span class="line"><span class="class">    //    template&lt;class T1,class T2,class T3&gt;T1 g2(T2 a,T3 b) &#123;int c=1;cout&lt;&lt;"g2"&lt;&lt;endl;return c;&#125;</span></span><br><span class="line"><span class="class">   // 类模板特化和部分特化的调用。</span></span><br><span class="line"><span class="class">     A&lt;int,int,int&gt; m1; m1.h();//正确，调用类模板的特化版本。</span></span><br><span class="line"><span class="class">     A&lt;int,double,int&gt; m; m.h(); //正确，调用类模板的部分特化版本。</span></span><br><span class="line"><span class="class">           //A&lt;int,int&gt; m2; //错误，类模板有三个类型形参，这里只提供了两个，数量不够，错误。</span></span><br><span class="line"><span class="class">     A&lt;double,double,int&gt; m3; m3.h();//调用类A的部分特化版本。</span></span><br><span class="line"><span class="class">     A&lt;double,int,int&gt; m4; m4.h();//调用类A的普通版本，在这里没有A&lt;double,int,int&gt;型的特化或者部分特化版本可用。</span></span><br><span class="line"><span class="class">     return 0;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2>函数模板重载（函数定制）：</h2>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11/14/Research-Records20181114/" rel="next" title="">
                <i class="fa fa-chevron-left"></i> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Bing</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">引子</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">2.</span> <span class="nav-text">函数模版</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">2.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">2.2.</span> <span class="nav-text">模板实参推演</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">2.3.</span> <span class="nav-text">函数模板的显式实例化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">2.4.</span> <span class="nav-text">显式模板实参</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">2.5.</span> <span class="nav-text">显式具体化(模板特化，模板说明) 和函数模板的重载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.5.1.</span> <span class="nav-text">特化函数模板：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">2.5.2.</span> <span class="nav-text">特化类模板：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">2.6.</span> <span class="nav-text">函数模板重载（函数定制）：</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bing</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
